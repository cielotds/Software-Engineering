<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Book</title>
</head>
<body>
    <br>
    <section>
        <h1>Integration with the Web</h1>
    </section>
    <br>
    <article>
        <p>There is an incredible amount of information on software engineering available on the
Web and some people have questioned if textbooks like this one are still needed.
However, the quality of available information is very patchy, information is sometimes
presented badly and it can be hard to find the information that you need. Consequently,
I believe that textbooks still have an important role to play in learning. They serve as a
roadmap to the subject and allow information on method and techniques to be organized
and presented in a coherent and readable way. They also provide a starting point for
deeper exploration of the research literature and material available on the Web.
I strongly believe that textbooks have a future but only if they are integrated with
and add value to material on the Web. This book has therefore been designed as a
hybrid print/web text in which core information in the printed edition is linked to
supplementary material on the Web. Almost all chapters include specially written
‘web sections’ that add to the information in that chapter. There are also four ‘web
chapters’ on topics that I have not covered in the print version of the book.
The website that is associated with the book is:</p>



<h3><a href="">http://www.SoftwareEngineering-9.com</a></h3>
<p>The book’s web has four principal components:</p>
    <ol>
            <li>Web sections These are extra sections that add to the content presented in each
chapter. These web sections are linked from breakout boxes in each chapter.</li>
            <li>Web chapters There are four web chapters covering formal methods, interaction
design, documentation, and application architectures. I may add other chapters
on new topics during the lifetime of the book.</li>
             <li>Material for instructors The material in this section is intended to support people who are teaching software engineering. See the “Support Materials” section
in this Preface.</li>
            <li>Case studies These provide additional information about the case studies used
in the book (insulin pump, mental health-care system, wilderness weather system) as well as information about further case studies, such as the failure of the
Ariane 5 launcher.</li>
    </ol>
    <p>As well as these sections, there are also links to other sites with useful material on
software engineering, further reading, blogs, newsletters, etc.
I welcome your constructive comments and suggestions about the book and the
website. You can contact me at ian@SoftwareEngineering-9.com. Please include
[SE9] in the subject of your message. Otherwise, my spam filters will probably
reject your mail and you will not receive a reply. I do not have time to help students
with their homework, so please don’t ask.</p>
    </article>
    <br>
    <section>
        <h1>Readership</h1>
        <p>The book is primarily aimed at university and college students taking introductory
and advanced courses in software and systems engineering. Software engineers in
the industry may find the book useful as general reading and as a means of updating
their knowledge on topics such as software reuse, architectural design, dependability
and security, and process improvement. I assume that readers have completed an
introductory programming course and are familiar with programming terminology.</p>
    </section>
    <br>
    <section>
    <h1>Changes from Previous Editions</h1>
    <p>The book is primarily aimed at university and college students taking introductory
and advanced courses in software and systems engineering. Software engineers in
the industry may find the book useful as general reading and as a means of updating
their knowledge on topics such as software reuse, architectural design, dependability
and security, and process improvement. I assume that readers have completed an
introductory programming course and are familiar with programming terminology.</p>
    <br>
    <ol>
    <li>The move from a print-only book to a hybrid print/web book with the web material tightly integrated with the sections in the book. This has allowed me to reduce
the number of chapters in the book and to focus on core material in each chapter.</li>
    <li>Complete restructuring to make it easier to use the book in teaching software
engineering. The book now has four rather than eight parts and each part may be
used on its own or in combination with other parts as the basis of a software
engineering course. The four parts are an introduction to software engineering,
dependability and security, advanced software engineering, and software engineering management</li>
    <li> Several topics from previous editions are presented more concisely in a single
chapter, with extra material moved onto the Web.</li>
    <li>Additional web chapters, based on chapters from previous editions that I have
not included here, are available on the Web.</li>
    <li> I have updated and revised the content in all chapters. I estimate that between
30% and 40% of the text has been completely rewritten.</li>
    <li> I have added new chapters on agile software development and embedded systems.</li>
    <li>As well as these new chapters, there is new material on model-driven engineering, open source development, test-driven development, Reason’s Swiss Cheese
model, dependable systems architectures, static analysis and model checking,
COTS reuse, software as a service, and agile planning</li>
    <li> A new case study on a patient record system for patients who are undergoing
treatment for mental health problems has been used in several chapters.</li>
    </ol>
    </section>
    <br>
    <section>
    <h1>Using Book for teaching</h1>
    <article>
    <p>I have designed the book so that it can be used in three different types of software
engineering courses:</p>
    <ol>
    <li>General introductory courses in software engineering The first part of the book
has been designed explicitly to support a one-semester course in introductory
software engineering.</li>
    <li>Introductory or intermediate courses on specific software engineering topics You
can create a range of more advanced courses using the chapters in Parts 2–4. For
example, I have taught a course in critical systems engineering using the chapters
in Part 2 plus chapters on quality management and configuration management.</li>
    <li>More advanced courses in specific software engineering topics In this case, the
chapters in the book form a foundation for the course. These are then supplemented with further reading that explores the topic in more detail. For example,
a course on software reuse could be based around Chapters 16, 17, 18, and 19.</li>
    <p>More information about using the book for teaching, including a comparison with
previous editions, is available on the book’s website.</p>
    </ol>
    </article>
    </section>
    <br>
    <section>
    <h1>Support Materials</h1>
    <article>
      <p>A wide range of support material is available to help people using the book for teaching software engineering courses. This includes:</p>
      <ul>
        <li> PowerPoint presentations for all of the chapters in the book.</li>
        <li>Figures in PowerPoint.</li>
        <li>An instructor’s guide that gives advice on how to use the book in different courses
        and explains the relationship between the chapters in this edition and previous
        editions.</li>
        <li>Further information on the book’s case studies.</li>
        <li>Additional case studies that may be used in software engineering courses.</li>
        <li>Additional PowerPoint presentations on systems engineering.</li>
        <li>Four web chapters covering formal methods, interaction design, application
architectures, and documentation.</li>
        <p>All of this material is available free to readers of the book from the book’s website or from the Pearson support site below. Additional material for instructors is
available on a restricted basis to accredited instructors only:</p>
        <li>Model answers to selected end-of-chapter exercises.</li>
        <li>Quiz questions and answers for each chapter</li>
      </ul>
      <p>All support material, including restricted material, is available from:</p>
      <a href="">http://www.pearsonhighered.com/sommerville/</a>
      <p>Instructors using the book for teaching may obtain a password to access restricted
material by registering at the Pearson website, by contacting their local Pearson representative, or by requesting a password by e-mail from computing@aw.com.
Passwords are not available from the author.</p>
        
    </article>
    </section>
    <br>
    <section>
        <h1>Acknowledgments</h1>
        <article>
            <p>A large number of people have contributed over the years to the evolution of this
book and I’d like to thank everyone (reviewers, students, and book users) who have
commented on previous editions and made constructive suggestions for change.
I’d particularly like to thank my family (Anne, Ali, and Jane) for their help and
support while the book was being written. A big thank-you especially to my daughter, Jane, who discovered a talent for proofreading and editing. She was tremendously helpful in reading the entire book and did a great job spotting and fixing a
large number of typos and grammatical errors.</p>
            <p>Ian Sommerville <br> October 2009</p>
        </article>
    </section>
    <section>
        <article>
            <img src="assets/part1.png" alt="" width="300" height="200">
        </article>
    </section>
    <br>
    <section>
        <article>
            <p>My aim in this part of the book is to provide a general introduction to
software engineering. I introduce important concepts such as software
processes and agile methods, and describe essential software development
activities, from initial software specification through to system evolution.
The chapters in this part have been designed to support a one-semester
course in software engineering.
Chapter 1 is a general introduction that introduces professional software
engineering and defines some software engineering concepts. I have
also written a brief discussion of ethical issues in software engineering.
I think that it is important for software engineers to think about the
wider implications of their work. This chapter also introduces three case
studies that I use in the book, namely a system for managing records of
patients undergoing treatment for mental health problems, a control
system for a portable insulin pump and a wilderness weather system.
Chapters 2 and 3 cover software engineering processes and agile development. In Chapter 2, I introduce commonly used generic software
process models, such as the waterfall model, and I discuss the basic
activities that are part of these processes. Chapter 3 supplements this
with a discussion of agile development methods for software engineering. I mostly use Extreme Programming as an example of an agile method
but also briefly introduce Scrum in this chapter.</p>
<br>
    <p>The remainder of the chapters in this part are extended descriptions of
the software process activities that will be introduced in Chapter 2.
Chapter 4 covers the critically important topic of requirements engineering, where the requirements for what a system should do are defined.
Chapter 5 introduces system modeling using the UML, where I focus on
the use of use case diagrams, class diagrams, sequence diagrams, and
state diagrams for modeling a software system. Chapter 6 introduces
architectural design and I discuss the importance of architecture and the
use of architectural patterns in software design.
Chapter 7 introduces object-oriented design and the use of design patterns. I also introduce important implementation issues here—reuse, configuration management, and host-target development and discuss open
source development. Chapter 8 focuses on software testing from unit testing during system development to the testing of software releases. I also
discuss the use of test-driven development—an approach pioneered in
agile methods but which has wide applicability. Finally, Chapter 9 presents an overview of software evolution issues. I cover evolution
processes, software maintenance, and legacy system management.</p>
        </article>
    </section>
    <br>
    <section>
        <h1>Objectives</h1>
        <article>
        <p>The objectives of this chapter are to introduce software engineering and
to provide a framework for understanding the rest of the book. When you
have read this chapter you will:</p>
        <ul>
            <li>understand what software engineering is and why it is important;</li>
            <li>understand that the development of different types of software
systems may require different software engineering techniques;</li>
            <li>understand some ethical and professional issues that are important
for software engineers;</li>
            <li>have been introduced to three systems, of different types, that will be
used as examples throughout the book.</li>

        </ul>
        <h3>Contents</h3>
        <h5>1.1 Professional software development</h5>
        <h5>1.2 Software engineering ethics</h5>
        <h5>1.3 Case studies</h5>
        </article>
    </section>
    <br>
    <section>
        <article>
        <img src="assets/table1.png" alt="" height="200" width="300">
    </article>
        <article>
            <p>Chapter 1: Introduction</p>
            <p>We can’t run the modern world without software. National infrastructures and utilities are controlled by computer-based systems and most electrical products include a
computer and controlling software. Industrial manufacturing and distribution is
completely computerized, as is the financial system. Entertainment, including the
music industry, computer games, and film and television, is software intensive.
Therefore, software engineering is essential for the functioning of national and international societies.
Software systems are abstract and intangible. They are not constrained by the
properties of materials, governed by physical laws, or by manufacturing processes.
This simplifies software engineering, as there are no natural limits to the potential of
software. However, because of the lack of physical constraints, software systems can
quickly become extremely complex, difficult to understand, and expensive to change.
There are many different types of software systems, from simple embedded systems to complex, worldwide information systems. It is pointless to look for universal
notations, methods, or techniques for software engineering because different types
of software require different approaches. Developing an organizational information
system is completely different from developing a controller for a scientific instrument. Neither of these systems has much in common with a graphics-intensive computer game. All of these applications need software engineering; they do not all need
the same software engineering techniques.
There are still many reports of software projects going wrong and ‘software failures’.
Software engineering is criticized as inadequate for modern software development.
However, in my view, many of these so-called software failures are a consequence of
two factors:</p>
<ol>
    <li>Increasing demands As new software engineering techniques help us to build
larger, more complex systems, the demands change. Systems have to be built
and delivered more quickly; larger, even more complex systems are required;
systems have to have new capabilities that were previously thought to be impossible. Existing software engineering methods cannot cope and new software
engineering techniques have to be developed to meet new these new demands.</li>
<li>Low expectations It is relatively easy to write computer programs without using
software engineering methods and techniques. Many companies have drifted
into software development as their products and services have evolved. They do
not use software engineering methods in their everyday work. Consequently,
their software is often more expensive and less reliable than it should be. We
need better software engineering education and training to address this problem.</li>
</ol>
<p>Software engineers can be rightly proud of their achievements. Of course we still
have problems developing complex software but, without software engineering, we
would not have explored space, would not have the Internet or modern telecommunications. All forms of travel would be more dangerous and expensive. Software engineering has contributed a great deal and I am convinced that its contributions in the
21st century will be even greater.</p>
        </article>
    </section>
    <br>
    <section>
        <article>
            <h1>History of Software engineering</h1>
            <p>The notion of ‘software engineering’ was first proposed in 1968 at a conference held to discuss what was then
called the ‘software crisis’ (Naur and Randell, 1969). It became clear that individual approaches to program
development did not scale up to large and complex software systems. These were unreliable, cost more than
expected, and were delivered late.
Throughout the 1970s and 1980s, a variety of new software engineering techniques and methods were
developed, such as structured programming, information hiding and object-oriented development. Tools and
standard notations were developed and are now extensively used.</p>
        <a href="">http://www.SoftwareEngineering-9.com/Web/History/</a>
        </article>
    </section>
    <br>
    <section>
        <article>
            <h1>1.1 Professional software development</h1>
            <h2>1.1.1 What is software?</h2>
            <p>Many people think that software is simply another word for computer programs. However, when we are talking about software engineering, software is not just the programs themselves but also all associated documentation and configuration data that is required to make these programs operate correctly. A professionally developed software system is often more than a single program. The system usually consists of a number of separate programs and configuration files that are used to set up these programs. It may include system documentation, which describes the structure of the system; user documentation, which explains how to use the system, and websites for users to download recent product information.</p>
            <h2>1.1.2 Software products</h2>
            <p>There are two kinds of software products:</p>
            <ul>
                <li><b>Generic products</b> – These are stand-alone systems that are produced by a development organization and sold on the open market to any customer who is able to buy them. Examples of this type of product include software for PCs such as databases, word processors, drawing packages, and project management tools.</li>
                <li><b>Customized (or bespoke) products</b> – These are systems that are commissioned by a particular customer. A software contractor develops the software especially for that customer. Examples include control systems for electronic devices, systems written to support a particular business process, and air traffic control systems.</li>
            </ul>
            <p>An important difference between these types of software is that, in generic products, the organization that develops the software controls the software specification. For custom products, the specification is usually developed and controlled by the organization that is buying the software. The software developers must work to that specification.</p>
            <p>However, the distinction between these system product types is becoming increasingly blurred. More and more systems are now being built with a generic product as a base, which is then adapted to suit the requirements of a customer. Enterprise Resource Planning (ERP) systems, such as the SAP system, are the best examples of this approach. Here, a large and complex system is adapted for a company by incorporating information about business rules and processes, reports required, and so on.</p>
            <h2>1.1.3 Software engineering and the Web</h2>
            <p>The development of the World Wide Web has had a profound effect on all of our lives. Initially, the Web was primarily a universally accessible information store and it had little effect on software systems. These systems ran on local computers and were only accessible from within an organization. Around 2000, the Web started to evolve and more and more functionality was added to browsers. This meant that web-based systems could be developed where, instead of a special-purpose user interface, these systems could be accessed using a web browser. This led to the development of a vast range of new system products that delivered innovative services, accessed over the Web. These are often funded by adverts that are displayed on the user’s screen and do not involve direct payment from users.</p>
            <p>As well as these system products, the development of web browsers that could run small programs and do some local processing led to an evolution in business and organizational software. Instead of writing software and deploying it on users’ PCs, the software was deployed on a web server. This made it much cheaper to change and upgrade the software, as there was no need to install the software on every PC. It also reduced costs, as user interface development is particularly expensive. Consequently, wherever it has been possible to do so, many businesses have moved to web-based interaction with company software systems.</p>
            <p>The next stage in the development of web-based systems was the notion of web services. Web services are software components that deliver specific, useful functionality and which are accessed over the Web. Applications are constructed by integrating these web services, which may be provided by different companies. In principle, this linking can be dynamic so that an application may use different web services each time that it is executed. I cover this approach to software development in Chapter 19.</p>
            <p>In the last few years, the notion of ‘software as a service’ has been developed. It has been proposed that software will not normally run on local computers but will run on ‘computing clouds’ that are accessed over the Internet. If you use a service such as web-based mail, you are using a cloud-based system. A computing cloud is a huge number of linked computer systems that is shared by many users. Users do not buy software but pay according to how much the software is used or are given free access in return for watching adverts that are displayed on their screen.</p>
            <p>The advent of the web, therefore, has led to a significant change in the way that business software is organized. Before the web, business applications were mostly monolithic, single programs running on single computers or computer clusters. Communications were local, within an organization. Now, software is highly distributed, sometimes across the world. Business applications are not programmed from scratch but involve extensive reuse of components and programs.</p>
            <p>This radical change in software organization has, obviously, led to changes in the ways that web-based systems are engineered. For example:</p>
        </article>
    </section>
    <br>
    <section>
        <article>
            <h1>1.2 Software engineering ethics</h1>
            <p>Like other engineering disciplines, software engineering is carried out within a legal and social framework that limits the freedom of engineers. Software engineers must accept that their work affects many people and must behave in an honest and ethically responsible way if they are to be respected as professionals. Ethical behaviour is more than simply upholding the law but involves following a set of principles that are morally correct.</p>
            <p>The ACM/IEEE Code of Ethics is a set of principles that software engineers should follow. Some of the most important ethical responsibilities are:</p>
            <ul>
                <li>Confidentiality – Respect the confidentiality of your employers or clients.</li>
                <li>Competence – Only accept work that you are competent to perform.</li>
                <li>Intellectual property rights – Respect the intellectual property of others.</li>
                <li>Computer misuse – Do not use your technical skills to misuse other people’s computers.</li>
            </ul>
            <p>Ethical dilemmas occur when different ethical principles conflict. For example, you may be asked to work on a project that you feel is outside your area of competence, or you may be asked to reveal confidential information. In such cases, you should discuss the situation with your managers and, if necessary, seek advice from professional organizations.</p>
        </article>
    </section>
    <br>
    <section>
        <article>
            <h1>1.3 Case studies</h1>
            <p>Throughout this book, three case studies are used to illustrate different aspects of software engineering:</p>
            <ol>
                <li><b>Insulin pump control system</b> – A real-time embedded system that controls a medical device for people with diabetes. This system is safety-critical and must be designed and implemented to ensure that it always delivers the correct dose of insulin to the patient. The software in the insulin pump monitors the patient’s blood sugar level and calculates the amount of insulin required. It then controls a motor that delivers the insulin through a needle into the patient’s body. The system must be able to detect and respond to hardware failures, such as a blocked needle or a low battery, and must provide appropriate warnings to the user.</li>
                <li><b>Patient information system for mental health care</b> – An information system for managing patient records in a mental health care setting. This system is used by doctors, nurses, and administrative staff to record and access information about patients, including their medical history, treatment plans, and progress notes. The system must ensure the confidentiality and security of patient data, support the workflow of the mental health care team, and provide timely access to information to support clinical decision-making. The system must also comply with relevant legal and ethical requirements for handling sensitive health information.</li>
                <li><b>Wilderness weather station</b> – A data collection system that gathers weather data from remote locations. This system consists of a set of weather stations located in remote areas, each equipped with sensors to measure temperature, humidity, wind speed, and other environmental variables. The weather stations transmit their data to a central server via satellite or radio links. The central server stores the data and provides access to users via a web interface. The system must be reliable and robust, as the weather stations may be difficult to access for maintenance, and must be able to operate in harsh environmental conditions.</li>
            </ol>
            <p>These case studies are described in more detail in later chapters and are used to demonstrate how software engineering techniques are applied in practice.</p>
        </article>
    </section>
    <br>
    <section>
        <article>
            <h1>Key points</h1>
            <ul>
                <li>Software engineering is an engineering discipline concerned with all aspects of software production.</li>
                <li>Essential software product attributes are maintainability, dependability, efficiency, and acceptability.</li>
                <li>The fundamental activities in software processes are specification, development, validation, and evolution.</li>
                <li>There are many different types of software systems and different application types require different development techniques.</li>
                <li>Professional software engineers should follow a code of ethics and professional practice.</li>
            </ul>
        </article>
    </section>
</body>
</html>