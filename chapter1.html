<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Book</title>
</head>
<body>
    <br>
    <section>
        <h1>Integration with the Web</h1>
    </section>
    <br>
    <article>
        <p>There is an incredible amount of information on software engineering available on the
Web and some people have questioned if textbooks like this one are still needed.
However, the quality of available information is very patchy, information is sometimes
presented badly and it can be hard to find the information that you need. Consequently,
I believe that textbooks still have an important role to play in learning. They serve as a
roadmap to the subject and allow information on method and techniques to be organized
and presented in a coherent and readable way. They also provide a starting point for
deeper exploration of the research literature and material available on the Web.
I strongly believe that textbooks have a future but only if they are integrated with
and add value to material on the Web. This book has therefore been designed as a
hybrid print/web text in which core information in the printed edition is linked to
supplementary material on the Web. Almost all chapters include specially written
‘web sections’ that add to the information in that chapter. There are also four ‘web
chapters’ on topics that I have not covered in the print version of the book.
The website that is associated with the book is:</p>



<h3><a href="">http://www.SoftwareEngineering-9.com</a></h3>
<p>The book’s web has four principal components:</p>
    <ol>
            <li>Web sections These are extra sections that add to the content presented in each
chapter. These web sections are linked from breakout boxes in each chapter.</li>
            <li>Web chapters There are four web chapters covering formal methods, interaction
design, documentation, and application architectures. I may add other chapters
on new topics during the lifetime of the book.</li>
             <li>Material for instructors The material in this section is intended to support people who are teaching software engineering. See the “Support Materials” section
in this Preface.</li>
            <li>Case studies These provide additional information about the case studies used
in the book (insulin pump, mental health-care system, wilderness weather system) as well as information about further case studies, such as the failure of the
Ariane 5 launcher.</li>
    </ol>
    <p>As well as these sections, there are also links to other sites with useful material on
software engineering, further reading, blogs, newsletters, etc.
I welcome your constructive comments and suggestions about the book and the
website. You can contact me at ian@SoftwareEngineering-9.com. Please include
[SE9] in the subject of your message. Otherwise, my spam filters will probably
reject your mail and you will not receive a reply. I do not have time to help students
with their homework, so please don’t ask.</p>
    </article>
    <br>
    <section>
        <h1>Readership</h1>
        <p>The book is primarily aimed at university and college students taking introductory
and advanced courses in software and systems engineering. Software engineers in
the industry may find the book useful as general reading and as a means of updating
their knowledge on topics such as software reuse, architectural design, dependability
and security, and process improvement. I assume that readers have completed an
introductory programming course and are familiar with programming terminology.</p>
    </section>
    <br>
    <section>
    <h1>Changes from Previous Editions</h1>
    <p>The book is primarily aimed at university and college students taking introductory
and advanced courses in software and systems engineering. Software engineers in
the industry may find the book useful as general reading and as a means of updating
their knowledge on topics such as software reuse, architectural design, dependability
and security, and process improvement. I assume that readers have completed an
introductory programming course and are familiar with programming terminology.</p>
    <br>
    <ol>
    <li>The move from a print-only book to a hybrid print/web book with the web material tightly integrated with the sections in the book. This has allowed me to reduce
the number of chapters in the book and to focus on core material in each chapter.</li>
    <li>Complete restructuring to make it easier to use the book in teaching software
engineering. The book now has four rather than eight parts and each part may be
used on its own or in combination with other parts as the basis of a software
engineering course. The four parts are an introduction to software engineering,
dependability and security, advanced software engineering, and software engineering management</li>
    <li> Several topics from previous editions are presented more concisely in a single
chapter, with extra material moved onto the Web.</li>
    <li>Additional web chapters, based on chapters from previous editions that I have
not included here, are available on the Web.</li>
    <li> I have updated and revised the content in all chapters. I estimate that between
30% and 40% of the text has been completely rewritten.</li>
    <li> I have added new chapters on agile software development and embedded systems.</li>
    <li>As well as these new chapters, there is new material on model-driven engineering, open source development, test-driven development, Reason’s Swiss Cheese
model, dependable systems architectures, static analysis and model checking,
COTS reuse, software as a service, and agile planning</li>
    <li> A new case study on a patient record system for patients who are undergoing
treatment for mental health problems has been used in several chapters.</li>
    </ol>
    </section>
    <br>
    <section>
    <h1>Using Book for teaching</h1>
    <article>
    <p>I have designed the book so that it can be used in three different types of software
engineering courses:</p>
    <ol>
    <li>General introductory courses in software engineering The first part of the book
has been designed explicitly to support a one-semester course in introductory
software engineering.</li>
    <li>Introductory or intermediate courses on specific software engineering topics You
can create a range of more advanced courses using the chapters in Parts 2–4. For
example, I have taught a course in critical systems engineering using the chapters
in Part 2 plus chapters on quality management and configuration management.</li>
    <li>More advanced courses in specific software engineering topics In this case, the
chapters in the book form a foundation for the course. These are then supplemented with further reading that explores the topic in more detail. For example,
a course on software reuse could be based around Chapters 16, 17, 18, and 19.</li>
    <p>More information about using the book for teaching, including a comparison with
previous editions, is available on the book’s website.</p>
    </ol>
    </article>
    </section>
    <br>
    <section>
    <h1>Support Materials</h1>
    <article>
      <p>A wide range of support material is available to help people using the book for teaching software engineering courses. This includes:</p>
      <ul>
        <li> PowerPoint presentations for all of the chapters in the book.</li>
        <li>Figures in PowerPoint.</li>
        <li>An instructor’s guide that gives advice on how to use the book in different courses
        and explains the relationship between the chapters in this edition and previous
        editions.</li>
        <li>Further information on the book’s case studies.</li>
        <li>Additional case studies that may be used in software engineering courses.</li>
        <li>Additional PowerPoint presentations on systems engineering.</li>
        <li>Four web chapters covering formal methods, interaction design, application
architectures, and documentation.</li>
        <p>All of this material is available free to readers of the book from the book’s website or from the Pearson support site below. Additional material for instructors is
available on a restricted basis to accredited instructors only:</p>
        <li>Model answers to selected end-of-chapter exercises.</li>
        <li>Quiz questions and answers for each chapter</li>
      </ul>
      <p>All support material, including restricted material, is available from:</p>
      <a href="">http://www.pearsonhighered.com/sommerville/</a>
      <p>Instructors using the book for teaching may obtain a password to access restricted
material by registering at the Pearson website, by contacting their local Pearson representative, or by requesting a password by e-mail from computing@aw.com.
Passwords are not available from the author.</p>
        
    </article>
    </section>
    <br>
    <section>
        <h1>Acknowledgments</h1>
        <article>
            <p>A large number of people have contributed over the years to the evolution of this
book and I’d like to thank everyone (reviewers, students, and book users) who have
commented on previous editions and made constructive suggestions for change.
I’d particularly like to thank my family (Anne, Ali, and Jane) for their help and
support while the book was being written. A big thank-you especially to my daughter, Jane, who discovered a talent for proofreading and editing. She was tremendously helpful in reading the entire book and did a great job spotting and fixing a
large number of typos and grammatical errors.</p>
            <p>Ian Sommerville <br> October 2009</p>
        </article>
    </section>
    <section>
        <article>
            <img src="assets/part1.png" alt="" width="300" height="200">
        </article>
    </section>
    <br>
    <section>
        <article>
            <p>My aim in this part of the book is to provide a general introduction to
software engineering. I introduce important concepts such as software
processes and agile methods, and describe essential software development
activities, from initial software specification through to system evolution.
The chapters in this part have been designed to support a one-semester
course in software engineering.
Chapter 1 is a general introduction that introduces professional software
engineering and defines some software engineering concepts. I have
also written a brief discussion of ethical issues in software engineering.
I think that it is important for software engineers to think about the
wider implications of their work. This chapter also introduces three case
studies that I use in the book, namely a system for managing records of
patients undergoing treatment for mental health problems, a control
system for a portable insulin pump and a wilderness weather system.
Chapters 2 and 3 cover software engineering processes and agile development. In Chapter 2, I introduce commonly used generic software
process models, such as the waterfall model, and I discuss the basic
activities that are part of these processes. Chapter 3 supplements this
with a discussion of agile development methods for software engineering. I mostly use Extreme Programming as an example of an agile method
but also briefly introduce Scrum in this chapter.</p>
<br>
    <p>The remainder of the chapters in this part are extended descriptions of
the software process activities that will be introduced in Chapter 2.
Chapter 4 covers the critically important topic of requirements engineering, where the requirements for what a system should do are defined.
Chapter 5 introduces system modeling using the UML, where I focus on
the use of use case diagrams, class diagrams, sequence diagrams, and
state diagrams for modeling a software system. Chapter 6 introduces
architectural design and I discuss the importance of architecture and the
use of architectural patterns in software design.
Chapter 7 introduces object-oriented design and the use of design patterns. I also introduce important implementation issues here—reuse, configuration management, and host-target development and discuss open
source development. Chapter 8 focuses on software testing from unit testing during system development to the testing of software releases. I also
discuss the use of test-driven development—an approach pioneered in
agile methods but which has wide applicability. Finally, Chapter 9 presents an overview of software evolution issues. I cover evolution
processes, software maintenance, and legacy system management.</p>
        </article>
    </section>
    <br>
    <section>
        <h1>Objectives</h1>
        <article>
        <p>The objectives of this chapter are to introduce software engineering and
to provide a framework for understanding the rest of the book. When you
have read this chapter you will:</p>
        <ul>
            <li>understand what software engineering is and why it is important;</li>
            <li>understand that the development of different types of software
systems may require different software engineering techniques;</li>
            <li>understand some ethical and professional issues that are important
for software engineers;</li>
            <li>have been introduced to three systems, of different types, that will be
used as examples throughout the book.</li>

        </ul>
        <h3>Contents</h3>
        <h5>1.1 Professional software development</h5>
        <h5>1.2 Software engineering ethics</h5>
        <h5>1.3 Case studies</h5>
        </article>
    </section>
    <br>
    <section>
        <article>
        <img src="assets/table1.png" alt="" height="200" width="300">
    </article>
        <article>
            <p>Chapter 1: Introduction</p>
            <p>We can’t run the modern world without software. National infrastructures and utilities are controlled by computer-based systems and most electrical products include a
computer and controlling software. Industrial manufacturing and distribution is
completely computerized, as is the financial system. Entertainment, including the
music industry, computer games, and film and television, is software intensive.
Therefore, software engineering is essential for the functioning of national and international societies.
Software systems are abstract and intangible. They are not constrained by the
properties of materials, governed by physical laws, or by manufacturing processes.
This simplifies software engineering, as there are no natural limits to the potential of
software. However, because of the lack of physical constraints, software systems can
quickly become extremely complex, difficult to understand, and expensive to change.
There are many different types of software systems, from simple embedded systems to complex, worldwide information systems. It is pointless to look for universal
notations, methods, or techniques for software engineering because different types
of software require different approaches. Developing an organizational information
system is completely different from developing a controller for a scientific instrument. Neither of these systems has much in common with a graphics-intensive computer game. All of these applications need software engineering; they do not all need
the same software engineering techniques.
There are still many reports of software projects going wrong and ‘software failures’.
Software engineering is criticized as inadequate for modern software development.
However, in my view, many of these so-called software failures are a consequence of
two factors:</p>
<ol>
    <li>Increasing demands As new software engineering techniques help us to build
larger, more complex systems, the demands change. Systems have to be built
and delivered more quickly; larger, even more complex systems are required;
systems have to have new capabilities that were previously thought to be impossible. Existing software engineering methods cannot cope and new software
engineering techniques have to be developed to meet new these new demands.</li>
<li>Low expectations It is relatively easy to write computer programs without using
software engineering methods and techniques. Many companies have drifted
into software development as their products and services have evolved. They do
not use software engineering methods in their everyday work. Consequently,
their software is often more expensive and less reliable than it should be. We
need better software engineering education and training to address this problem.</li>
</ol>
<p>Software engineers can be rightly proud of their achievements. Of course we still
have problems developing complex software but, without software engineering, we
would not have explored space, would not have the Internet or modern telecommunications. All forms of travel would be more dangerous and expensive. Software engineering has contributed a great deal and I am convinced that its contributions in the
21st century will be even greater.</p>
        </article>
    </section>
    <br>
    <section>
        <article>
            <h1>History of Software engineering</h1>
            <p>The notion of ‘software engineering’ was first proposed in 1968 at a conference held to discuss what was then
called the ‘software crisis’ (Naur and Randell, 1969). It became clear that individual approaches to program
development did not scale up to large and complex software systems. These were unreliable, cost more than
expected, and were delivered late.
Throughout the 1970s and 1980s, a variety of new software engineering techniques and methods were
developed, such as structured programming, information hiding and object-oriented development. Tools and
standard notations were developed and are now extensively used.</p>
        <a href="">http://www.SoftwareEngineering-9.com/Web/History/</a>
        </article>
    </section>
    <br>
    <section>
        <article>
            <h1>1.1 Professional software development</h1>
            <h2>1.1.1 What is software?</h2>
            <p>Many people think that software is simply another word for computer programs. However, when we are talking about software engineering, software is not just the programs themselves but also all associated documentation and configuration data that is required to make these programs operate correctly. A professionally developed software system is often more than a single program. The system usually consists of a number of separate programs and configuration files that are used to set up these programs. It may include system documentation, which describes the structure of the system; user documentation, which explains how to use the system, and websites for users to download recent product information.</p>
            <article>
                <img src="assets/table2.png" alt="" height="200" width="300">
            </article>
            <h2>1.1.2 Software products</h2>
            <p>There are two kinds of software products:</p>
            <ul>
                <li><b>Generic products</b> – These are stand-alone systems that are produced by a development organization and sold on the open market to any customer who is able to buy them. Examples of this type of product include software for PCs such as databases, word processors, drawing packages, and project management tools.</li>
                <li><b>Customized (or bespoke) products</b> – These are systems that are commissioned by a particular customer. A software contractor develops the software especially for that customer. Examples include control systems for electronic devices, systems written to support a particular business process, and air traffic control systems.</li>
            </ul>
            <p>An important difference between these types of software is that, in generic products, the organization that develops the software controls the software specification. For custom products, the specification is usually developed and controlled by the organization that is buying the software. The software developers must work to that specification.</p>
            <p>However, the distinction between these system product types is becoming increasingly blurred. More and more systems are now being built with a generic product as a base, which is then adapted to suit the requirements of a customer. Enterprise Resource Planning (ERP) systems, such as the SAP system, are the best examples of this approach. Here, a large and complex system is adapted for a company by incorporating information about business rules and processes, reports required, and so on.</p>
            <h2>1.1.3 Software engineering and the Web</h2>
            <p>The development of the World Wide Web has had a profound effect on all of our lives. Initially, the Web was primarily a universally accessible information store and it had little effect on software systems. These systems ran on local computers and were only accessible from within an organization. Around 2000, the Web started to evolve and more and more functionality was added to browsers. This meant that web-based systems could be developed where, instead of a special-purpose user interface, these systems could be accessed using a web browser. This led to the development of a vast range of new system products that delivered innovative services, accessed over the Web. These are often funded by adverts that are displayed on the user’s screen and do not involve direct payment from users.</p>
            <p>As well as these system products, the development of web browsers that could run small programs and do some local processing led to an evolution in business and organizational software. Instead of writing software and deploying it on users’ PCs, the software was deployed on a web server. This made it much cheaper to change and upgrade the software, as there was no need to install the software on every PC. It also reduced costs, as user interface development is particularly expensive. Consequently, wherever it has been possible to do so, many businesses have moved to web-based interaction with company software systems.</p>
            <p>The next stage in the development of web-based systems was the notion of web services. Web services are software components that deliver specific, useful functionality and which are accessed over the Web. Applications are constructed by integrating these web services, which may be provided by different companies. In principle, this linking can be dynamic so that an application may use different web services each time that it is executed. I cover this approach to software development in Chapter 19.</p>
            <p>In the last few years, the notion of ‘software as a service’ has been developed. It has been proposed that software will not normally run on local computers but will run on ‘computing clouds’ that are accessed over the Internet. If you use a service such as web-based mail, you are using a cloud-based system. A computing cloud is a huge number of linked computer systems that is shared by many users. Users do not buy software but pay according to how much the software is used or are given free access in return for watching adverts that are displayed on their screen.</p>
            <p>The advent of the web, therefore, has led to a significant change in the way that business software is organized. Before the web, business applications were mostly monolithic, single programs running on single computers or computer clusters. Communications were local, within an organization. Now, software is highly distributed, sometimes across the world. Business applications are not programmed from scratch but involve extensive reuse of components and programs.</p>
            <p>This radical change in software organization has, obviously, led to changes in the ways that web-based systems are engineered. For example:</p>
        </article>
    </section>
    <br>
    <section>
        <article>
            <h1>1.2 Software engineering ethics</h1>
            <article>
                <img src="assets/table3.png" alt="" height="200" width="300">
                <p>Professional societies and institutions have an important role to play in setting
ethical standards. Organizations such as the ACM, the IEEE (Institute of Electrical
and Electronic Engineers), and the British Computer Society publish a code of
professional conduct or code of ethics. Members of these organizations undertake to
follow that code when they sign up for membership. These codes of conduct are generally concerned with fundamental ethical behavior.
Professional associations, notably the ACM and the IEEE, have cooperated to
produce a joint code of ethics and professional practice. This code exists in both a
short form, shown in Figure 1.3, and a longer form (Gotterbarn et al., 1999) that adds
detail and substance to the shorter version. The rationale behind this code is summarized in the first two paragraphs of the longer form:
Computers have a central and growing role in commerce, industry, government,
medicine, education, entertainment and society at large. Software engineers are
those who contribute by direct participation or by teaching, to the analysis, specification, design, development, certification, maintenance and testing of software
Software Engineering Code of Ethics and Professional Practice
ACM/IEEE-CS Joint Task Force on Software Engineering Ethics and Professional Practices
PREAMBLE
The short version of the code summarizes aspirations at a high level of the abstraction; the clauses that are
included in the full version give examples and details of how these aspirations change the way we act as
software engineering professionals. Without the aspirations, the details can become legalistic and tedious;
without the details, the aspirations can become high sounding but empty; together, the aspirations and the
details form a cohesive code.
Software engineers shall commit themselves to making the analysis, specification, design, development,
testing and maintenance of software a beneficial and respected profession. In accordance with their
commitment to the health, safety and welfare of the public, software engineers shall adhere to the following
Eight Principles:
1. PUBLIC — Software engineers shall act consistently with the public interest.
2. CLIENT AND EMPLOYER — Software engineers shall act in a manner that is in the
best interests of their client and employer consistent with the public interest.
3. PRODUCT — Software engineers shall ensure that their products and related
modifications meet the highest professional standards possible.
4. JUDGMENT — Software engineers shall maintain integrity and independence in their
professional judgment.
5. MANAGEMENT — Software engineering managers and leaders shall subscribe to and
promote an ethical approach to the management of software development and
maintenance.
6. PROFESSION — Software engineers shall advance the integrity and reputation of
the profession consistent with the public interest.
7. COLLEAGUES — Software engineers shall be fair to and supportive of their
colleagues.
8. SELF — Software engineers shall participate in lifelong learning regarding the
practice of their profession and shall promote an ethical approach to the
practice of the profession.
Figure 1.3 The
ACM/IEEE Code of
Ethics (© IEEE/ACM
1999)
16 Chapter 1 ■ Introduction
systems. Because of their roles in developing software systems, software engineers have significant opportunities to do good or cause harm, to enable others to
do good or cause harm, or to influence others to do good or cause harm. To
ensure, as much as possible, that their efforts will be used for good, software engineers must commit themselves to making software engineering a beneficial and
respected profession. In accordance with that commitment, software engineers
shall adhere to the following Code of Ethics and Professional Practice.
The Code contains eight Principles related to the behaviour of and decisions
made by professional software engineers, including practitioners, educators,
managers, supervisors and policy makers, as well as trainees and students of
the profession. The Principles identify the ethically responsible relationships
in which individuals, groups, and organizations participate and the primary
obligations within these relationships. The Clauses of each Principle are illustrations of some of the obligations included in these relationships. These obligations are founded in the software engineer’s humanity, in special care owed
to people affected by the work of software engineers, and the unique elements
of the practice of software engineering. The Code prescribes these as obligations of anyone claiming to be or aspiring to be a software engineer.
In any situation where different people have different views and objectives you
are likely to be faced with ethical dilemmas. For example, if you disagree, in principle, with the policies of more senior management in the company, how should you
react? Clearly, this depends on the particular individuals and the nature of the disagreement. Is it best to argue a case for your position from within the organization or
to resign in principle? If you feel that there are problems with a software project,
when do you reveal these to management? If you discuss these while they are just a
suspicion, you may be overreacting to a situation; if you leave it too late, it may be
impossible to resolve the difficulties.
Such ethical dilemmas face all of us in our professional lives and, fortunately, in
most cases they are either relatively minor or can be resolved without too much difficulty. Where they cannot be resolved, the engineer is faced with, perhaps, another
problem. The principled action may be to resign from their job but this may well
affect others such as their partner or their children.
A particularly difficult situation for professional engineers arises when their
employer acts in an unethical way. Say a company is responsible for developing a
safety-critical system and, because of time pressure, falsifies the safety validation
records. Is the engineer’s responsibility to maintain confidentiality or to alert the
customer or publicize, in some way, that the delivered system may be unsafe?
The problem here is that there are no absolutes when it comes to safety. Although
the system may not have been validated according to predefined criteria, these criteria may be too strict. The system may actually operate safely throughout its lifetime.
It is also the case that, even when properly validated, the system may fail and cause
an accident. Early disclosure of problems may result in damage to the employer and
other employees; failure to disclose problems may result in damage to others.</p>
            </article>
            <p>Like other engineering disciplines, software engineering is carried out within a legal and social framework that limits the freedom of engineers. Software engineers must accept that their work affects many people and must behave in an honest and ethically responsible way if they are to be respected as professionals. Ethical behaviour is more than simply upholding the law but involves following a set of principles that are morally correct.</p>
            <p>The ACM/IEEE Code of Ethics is a set of principles that software engineers should follow. Some of the most important ethical responsibilities are:</p>
            <ul>
                <li>Confidentiality – Respect the confidentiality of your employers or clients.</li>
                <li>Competence – Only accept work that you are competent to perform.</li>
                <li>Intellectual property rights – Respect the intellectual property of others.</li>
                <li>Computer misuse – Do not use your technical skills to misuse other people’s computers.</li>
            </ul>
            <p>Ethical dilemmas occur when different ethical principles conflict. For example, you may be asked to work on a project that you feel is outside your area of competence, or you may be asked to reveal confidential information. In such cases, you should discuss the situation with your managers and, if necessary, seek advice from professional organizations.</p>
        </article>
    </section>
    <article>
        <p>The development of the World Wide Web has had a profound effect on all of our
lives. Initially, the Web was primarily a universally accessible information store and
it had little effect on software systems. These systems ran on local computers and
were only accessible from within an organization. Around 2000, the Web started to
evolve and more and more functionality was added to browsers. This meant that
web-based systems could be developed where, instead of a special-purpose user
interface, these systems could be accessed using a web browser. This led to the
development of a vast range of new system products that delivered innovative services, accessed over the Web. These are often funded by adverts that are displayed on
the user’s screen and do not involve direct payment from users.
As well as these system products, the development of web browsers that could
run small programs and do some local processing led to an evolution in business and
organizational software. Instead of writing software and deploying it on users’ PCs,
the software was deployed on a web server. This made it much cheaper to change
and upgrade the software, as there was no need to install the software on every PC. It
also reduced costs, as user interface development is particularly expensive.
Consequently, wherever it has been possible to do so, many businesses have moved
to web-based interaction with company software systems.
The next stage in the development of web-based systems was the notion of web
services. Web services are software components that deliver specific, useful functionality and which are accessed over the Web. Applications are constructed by integrating
these web services, which may be provided by different companies. In principle, this
linking can be dynamic so that an application may use different web services each time
that it is executed. I cover this approach to software development in Chapter 19.
In the last few years, the notion of ‘software as a service’ has been developed. It
has been proposed that software will not normally run on local computers but will
run on ‘computing clouds’ that are accessed over the Internet. If you use a service
such as web-based mail, you are using a cloud-based system. A computing cloud is
a huge number of linked computer systems that is shared by many users. Users do
not buy software but pay according to how much the software is used or are given
free access in return for watching adverts that are displayed on their screen.
The advent of the web, therefore, has led to a significant change in the way that
business software is organized. Before the web, business applications were mostly
monolithic, single programs running on single computers or computer clusters.
Communications were local, within an organization. Now, software is highly distributed, sometimes across the world. Business applications are not programmed from
scratch but involve extensive reuse of components and programs.
This radical change in software organization has, obviously, led to changes in the
ways that web-based systems are engineered. For example:
1. Software reuse has become the dominant approach for constructing web-based
systems. When building these systems, you think about how you can assemble
them from pre-existing software components and systems.</p>
    </article>
    <br>
    <section>
        <article>
            <h1>1.3 Case studies</h1>
            <p>You must make up your own mind in these matters. The appropriate ethical position here depends entirely on the views of the individuals who are involved. In this
case, the potential for damage, the extent of the damage, and the people affected by
the damage should influence the decision. If the situation is very dangerous, it may
be justified to publicize it using the national press (say). However, you should
always try to resolve the situation while respecting the rights of your employer.
Another ethical issue is participation in the development of military and nuclear
systems. Some people feel strongly about these issues and do not wish to participate in
any systems development associated with military systems. Others will work on military systems but not on weapons systems. Yet others feel that national security is an
overriding principle and have no ethical objections to working on weapons systems.
In this situation, it is important that both employers and employees should make
their views known to each other in advance. Where an organization is involved in
military or nuclear work, they should be able to specify that employees must be willing to accept any work assignment. Equally, if an employee is taken on and makes
clear that they do not wish to work on such systems, employers should not put pressure on them to do so at some later date.
The general area of ethics and professional responsibility is becoming more
important as software-intensive systems pervade every aspect of work and everyday
life. It can be considered from a philosophical standpoint where the basic principles
of ethics are considered and software engineering ethics are discussed with reference
to these basic principles. This is the approach taken by Laudon (1995) and to a lesser
extent by Huff and Martin (1995). Johnson’s text on computer ethics (2001) also
approaches the topic from a philosophical perspective.
However, I find that this philosophical approach is too abstract and difficult to
relate to everyday experience. I prefer the more concrete approach embodied in codes
of conduct and practice. I think that ethics are best discussed in a software engineering context and not as a subject in their own right. In this book, therefore, I do not
include abstract ethical discussions but, where appropriate, include examples in the
exercises that can be the starting point for a group discussion on ethical issues.
1.3 Case studies
To illustrate software engineering concepts, I use examples from three different
types of systems throughout the book. The reason why I have not used a single case
study is that one of the key messages in this book is that software engineering practice depends on the type of systems being produced. I therefore choose an appropriate example when discussing concepts such as safety and dependability, system
modeling, reuse, etc.
The three types of systems that I use as case studies are: <br>
1. An embedded system This is a system where the software controls a hardware
device and is embedded in that device. Issues in embedded systems typically
include physical size, responsiveness, power management, etc. The example of an
embedded system that I use is a software system to control a medical device. <br>
2. An information system This is a system whose primary purpose is to manage
and provide access to a database of information. Issues in information systems
include security, usability, privacy, and maintaining data integrity. The example
of an information system that I use is a medical records system. <br>
3. A sensor-based data collection system This is a system whose primary purpose
is to collect data from a set of sensors and process that data in some way. The
key requirements of such systems are reliability, even in hostile environmental
conditions, and maintainability. The example of a data collection system that
I use is a wilderness weather station.
I introduce each of these systems in this chapter, with more information about
each of them available on the Web</p>
            <p>Throughout this book, three case studies are used to illustrate different aspects of software engineering:</p>
            <ol>
                <li><b>Insulin pump control system</b> – A real-time embedded system that controls a medical device for people with diabetes. This system is safety-critical and must be designed and implemented to ensure that it always delivers the correct dose of insulin to the patient. The software in the insulin pump monitors the patient’s blood sugar level and calculates the amount of insulin required. It then controls a motor that delivers the insulin through a needle into the patient’s body. The system must be able to detect and respond to hardware failures, such as a blocked needle or a low battery, and must provide appropriate warnings to the user.</li>
                <li><b>Patient information system for mental health care</b> – An information system for managing patient records in a mental health care setting. This system is used by doctors, nurses, and administrative staff to record and access information about patients, including their medical history, treatment plans, and progress notes. The system must ensure the confidentiality and security of patient data, support the workflow of the mental health care team, and provide timely access to information to support clinical decision-making. The system must also comply with relevant legal and ethical requirements for handling sensitive health information.</li>
                <li><b>Wilderness weather station</b> – A data collection system that gathers weather data from remote locations. This system consists of a set of weather stations located in remote areas, each equipped with sensors to measure temperature, humidity, wind speed, and other environmental variables. The weather stations transmit their data to a central server via satellite or radio links. The central server stores the data and provides access to users via a web interface. The system must be reliable and robust, as the weather stations may be difficult to access for maintenance, and must be able to operate in harsh environmental conditions.</li>
            </ol>
            <article>
                <img src="assets/table4.png" alt="">
            </article>
            <p>These case studies are described in more detail in later chapters and are used to demonstrate how software engineering techniques are applied in practice.</p>
        </article>
        <article>
            <img src="assets/table5.png" alt="">
        </article>
    </section>
    <p>The nature of mental health problems is such that patients are often disorganized
so may miss appointments, deliberately or accidentally lose prescriptions and medication, forget instructions, and make unreasonable demands on medical staff. They
may drop in on clinics unexpectedly. In a minority of cases, they may be a danger to
themselves or to other people. They may regularly change address or may be homeless on a long-term or short-term basis. Where patients are dangerous, they may need
to be ‘sectioned’—confined to a secure hospital for treatment and observation.
Users of the system include clinical staff such as doctors, nurses, and health visitors (nurses who visit people at home to check on their treatment). Nonmedical users
include receptionists who make appointments, medical records staff who maintain
the records system, and administrative staff who generate reports.
The system is used to record information about patients (name, address, age, next
of kin, etc.), consultations (date, doctor seen, subjective impressions of the patient,
etc.), conditions, and treatments. Reports are generated at regular intervals for medical staff and health authority managers. Typically, reports for medical staff focus on
information about individual patients whereas management reports are anonymized
and are concerned with conditions, costs of treatment, etc.
The key features of the system are:
<br>
1. Individual care management Clinicians can create records for patients, edit the
information in the system, view patient history, etc. The system supports data
summaries so that doctors who have not previously met a patient can quickly
learn about the key problems and treatments that have been prescribed.
<br>
2. Patient monitoring The system regularly monitors the records of patients that
are involved in treatment and issues warnings if possible problems are detected.
Therefore, if a patient has not seen a doctor for some time, a warning may be
issued. One of the most important elements of the monitoring system is to keep
track of patients who have been sectioned and to ensure that the legally required
checks are carried out at the right time.
<br>
3. Administrative reporting The system generates monthly management reports
showing the number of patients treated at each clinic, the number of patients
who have entered and left the care system, number of patients sectioned, the
drugs prescribed and their costs, etc.
Two different laws affect the system. These are laws on data protection that govern
the confidentiality of personal information and mental health laws that govern the compulsory detention of patients deemed to be a danger to themselves or others. Mental
health is unique in this respect as it is the only medical speciality that can recommend
the detention of patients against their will. This is subject to very strict legislative safeguards. One of the aims of the MHC-PMS is to ensure that staff always act in accordance with the law and that their decisions are recorded for judicial review if necessary.
As in all medical systems, privacy is a critical system requirement. It is essential that
patient information is confidential and is never disclosed to anyone apart from authorized medical staff and the patient themselves. The MHC-PMS is also a safety-critical</p>
    <br>
    <article>
        <img src="assets/table6.png" alt="">
    </article>
    <section>
        <article>
            <h1>Key points</h1>
            <ul>
                <li>Software engineering is an engineering discipline concerned with all aspects of software production.</li>
                <li>Essential software product attributes are maintainability, dependability, efficiency, and acceptability.</li>
                <li>The fundamental activities in software processes are specification, development, validation, and evolution.</li>
                <li>There are many different types of software systems and different application types require different development techniques.</li>
                <li>Professional software engineers should follow a code of ethics and professional practice.</li>
            </ul>
        </article>
    </section>
</body>
</html>